local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local PhysicsService = game:GetService("PhysicsService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- =========================
-- UI SCALE (smaller menu)
-- =========================
local UI_SCALE = 0.75
local function S(n: number): number
	return math.max(1, math.floor(n * UI_SCALE + 0.5))
end
local BUTTON_HEIGHT = S(26)
local SWITCH_WIDTH = S(52)
local SWITCH_GAP = S(6)
local SWITCH_HEIGHT = BUTTON_HEIGHT
local SWITCH_PADDING = S(3)
local SWITCH_KNOB_SIZE = SWITCH_HEIGHT - (SWITCH_PADDING * 2)

-- =========================
-- DEFAULT BINDS (can rebind in GUI)
-- =========================
local espBind = { kind = "KeyCode", value = Enum.KeyCode.M }
local aimBind = { kind = "UserInputType", value = Enum.UserInputType.MouseButton2 } -- hold
local noclipBind = { kind = "KeyCode", value = Enum.KeyCode.CapsLock }

-- =========================
-- ESP SETTINGS
-- =========================
local RAINBOW_SPEED = 0.35
local HIGHLIGHT_OUTLINE = Color3.fromRGB(255, 255, 255)
local HIGHLIGHT_FILL_TRANSPARENCY = 0.5
local HIGHLIGHT_NAME = "AnomalyESP_Highlight"

-- =========================
-- AIM SETTINGS
-- =========================
local MAX_RAY_DISTANCE = 1000
local MAX_SNAP_TO_RAY = 8

-- =========================
-- LASER VISUAL
-- =========================
local LASER_WIDTH_0 = 0.08
local LASER_WIDTH_1 = 0.08
local LASER_TRANSPARENCY = 0.15

-- =========================
-- UI COLORS
-- =========================
local SWITCH_OFF = Color3.fromRGB(85, 85, 95)
local REBIND_BG_IDLE = Color3.fromRGB(26, 26, 32)
local REBIND_BG_HOVER = Color3.fromRGB(36, 36, 46)
local REBIND_BG_DOWN  = Color3.fromRGB(44, 44, 58)

-- =========================
-- STATE
-- =========================
local espArmed = true
local aimArmed = true
local noclipArmed = true
local espEnabled = false
local aimEnabled = false
local noclipEnabled = false
local targetPart: BasePart? = nil
local selectedPartName = "Head"

-- =========================
-- NOCLIP SETTINGS
-- =========================
local NOCLIP_GROUP = "NoclipLocal"

pcall(function()
	PhysicsService:CreateCollisionGroup(NOCLIP_GROUP)
end)

pcall(function()
	for _, g in ipairs(PhysicsService:GetCollisionGroups()) do
		PhysicsService:CollisionGroupSetCollidable(NOCLIP_GROUP, g.name, false)
	end
end)

local noclipParts = {} :: { BasePart }
local noclipOriginal = {} :: { [BasePart]: { CanCollide: boolean, CanTouch: boolean, CanQuery: boolean, CollisionGroup: string } }

local function rememberNoclipOriginal(p: BasePart)
	if noclipOriginal[p] then return end
	noclipOriginal[p] = {
		CanCollide = p.CanCollide,
		CanTouch = p.CanTouch,
		CanQuery = p.CanQuery,
		CollisionGroup = p.CollisionGroup,
	}
end

local function applyNoclipToPart(p: BasePart)
	rememberNoclipOriginal(p)
	p.CanCollide = false
	p.CanTouch = false
	p.CanQuery = false
	p.CollisionGroup = NOCLIP_GROUP
end

local function restoreNoclipPart(p: BasePart)
	local o = noclipOriginal[p]
	if not o then return end
	p.CanCollide = o.CanCollide
	p.CanTouch = o.CanTouch
	p.CanQuery = o.CanQuery
	p.CollisionGroup = o.CollisionGroup
end

local function collectNoclipParts(character: Model)
	table.clear(noclipParts)
	for _, d in ipairs(character:GetDescendants()) do
		if d:IsA("BasePart") then
			table.insert(noclipParts, d)
		end
	end
end

local function onNoclipCharacterAdded(character: Model)
	noclipOriginal = {}
	collectNoclipParts(character)
	if noclipEnabled then
		for _, p in ipairs(noclipParts) do
			if p and p.Parent then
				applyNoclipToPart(p)
			end
		end
	end

	character.DescendantAdded:Connect(function(d)
		if d:IsA("BasePart") then
			table.insert(noclipParts, d)
			if noclipEnabled then
				applyNoclipToPart(d)
			end
		end
	end)
end

local function setNoclipState(state: boolean)
	noclipEnabled = state

	if noclipEnabled then
		for _, p in ipairs(noclipParts) do
			if p and p.Parent then
				applyNoclipToPart(p)
			end
		end
	else
		for _, p in ipairs(noclipParts) do
			if p and p.Parent then
				restoreNoclipPart(p)
			end
		end
	end
end

if LocalPlayer.Character then
	onNoclipCharacterAdded(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(onNoclipCharacterAdded)

-- =========================
-- HELPERS
-- =========================
local function alive(char: Model?)
	local hum = char and char:FindFirstChildOfClass("Humanoid")
	return hum and hum.Health > 0
end

local function pointToRayDistance(origin: Vector3, dirUnit: Vector3, point: Vector3)
	local v = point - origin
	local t = v:Dot(dirUnit)
	if t <= 0 or t > MAX_RAY_DISTANCE then
		return math.huge, t
	end
	local closest = origin + dirUnit * t
	return (point - closest).Magnitude, t
end

local function getCharPart(char: Model, name: string): BasePart?
	local p = char:FindFirstChild(name)
	if p and p:IsA("BasePart") then return p end

	if name == "UpperTorso" or name == "LowerTorso" then
		local torso = char:FindFirstChild("Torso")
		if torso and torso:IsA("BasePart") then return torso end
	end
	if name == "Torso" then
		local ut = char:FindFirstChild("UpperTorso")
		if ut and ut:IsA("BasePart") then return ut end
		local lt = char:FindFirstChild("LowerTorso")
		if lt and lt:IsA("BasePart") then return lt end
	end
	return nil
end

local function findLaserClosestPart(partName: string)
	local origin = Camera.CFrame.Position
	local dir = Camera.CFrame.LookVector.Unit

	local bestPart = nil
	local bestDist = math.huge
	local bestT = math.huge

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer then
			local char = plr.Character
			if char and alive(char) then
				local part = getCharPart(char, partName)
				if part then
					local dist, t = pointToRayDistance(origin, dir, part.Position)
					if dist <= MAX_SNAP_TO_RAY then
						if dist < bestDist or (dist == bestDist and t < bestT) then
							bestDist, bestT, bestPart = dist, t, part
						end
					end
				end
			end
		end
	end

	return bestPart
end

-- =========================
-- ESP (HIGHLIGHT)
-- =========================
local function ensureHighlight(plr: Player)
	if plr == LocalPlayer then return nil end
	local char = plr.Character
	if not char then return nil end

	local hl = char:FindFirstChild(HIGHLIGHT_NAME)
	if not hl then
		hl = Instance.new("Highlight")
		hl.Name = HIGHLIGHT_NAME
		hl.Adornee = char
		hl.Parent = char
		hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		hl.OutlineColor = HIGHLIGHT_OUTLINE
		hl.FillTransparency = HIGHLIGHT_FILL_TRANSPARENCY
	end
	return hl
end

local function removeHighlight(plr: Player)
	if plr == LocalPlayer then return end
	local char = plr.Character
	if not char then return end
	local hl = char:FindFirstChild(HIGHLIGHT_NAME)
	if hl then hl:Destroy() end
end

local function removeAllHighlights()
	for _, plr in ipairs(Players:GetPlayers()) do
		removeHighlight(plr)
	end
end

-- =========================
-- LASER (BEAM)
-- =========================
local laserBeam: Beam? = nil
local a0: Attachment? = nil
local a1: Attachment? = nil
local laserEndPart: Part? = nil
local laserStartPart: Part? = nil

local function destroyLaser()
	if laserBeam then laserBeam:Destroy() laserBeam = nil end
	if a0 then a0:Destroy() a0 = nil end
	if a1 then a1:Destroy() a1 = nil end
	if laserEndPart then laserEndPart:Destroy() laserEndPart = nil end
	if laserStartPart then laserStartPart:Destroy() laserStartPart = nil end
end

local function ensureLaser()
	if laserBeam and a0 and a1 and laserEndPart and laserStartPart then return end

	laserStartPart = Instance.new("Part")
	laserStartPart.Name = "LaserStartPart"
	laserStartPart.Anchored = true
	laserStartPart.CanCollide = false
	laserStartPart.CanQuery = false
	laserStartPart.CanTouch = false
	laserStartPart.Transparency = 1
	laserStartPart.Size = Vector3.new(0.1, 0.1, 0.1)
	laserStartPart.Parent = Workspace

	a0 = Instance.new("Attachment")
	a0.Name = "LaserStart"
	a0.Parent = laserStartPart

	laserEndPart = Instance.new("Part")
	laserEndPart.Name = "LaserEndPart"
	laserEndPart.Anchored = true
	laserEndPart.CanCollide = false
	laserEndPart.CanQuery = false
	laserEndPart.CanTouch = false
	laserEndPart.Transparency = 1
	laserEndPart.Size = Vector3.new(0.1, 0.1, 0.1)
	laserEndPart.Parent = Workspace

	a1 = Instance.new("Attachment")
	a1.Name = "LaserEnd"
	a1.Parent = laserEndPart

	laserBeam = Instance.new("Beam")
	laserBeam.Name = "LaserBeam"
	laserBeam.Attachment0 = a0
	laserBeam.Attachment1 = a1
	laserBeam.Width0 = LASER_WIDTH_0
	laserBeam.Width1 = LASER_WIDTH_1
	laserBeam.LightInfluence = 0
	laserBeam.FaceCamera = true
	laserBeam.Transparency = NumberSequence.new(LASER_TRANSPARENCY)
	laserBeam.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))
	laserBeam.Parent = Workspace
end

local function setLaserEndPosition(pos: Vector3)
	if laserEndPart then
		laserEndPart.CFrame = CFrame.new(pos)
	end
end

local function updateLaserStart()
	if laserStartPart then
		laserStartPart.CFrame = Camera.CFrame
	end
end

-- =========================
-- AIM START/STOP
-- =========================
local function aimStart()
	aimEnabled = true
	targetPart = findLaserClosestPart(selectedPartName)
	if not targetPart then
		aimEnabled = false
		targetPart = nil
		destroyLaser()
		return
	end
	ensureLaser()
end

local function aimStop()
	aimEnabled = false
	targetPart = nil
	destroyLaser()
end

-- =========================
-- GUI BUILD (ALWAYS ON TOP)
-- =========================
local gui = Instance.new("ScreenGui")
gui.Name = "ESP_AIM_StatusGui"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.DisplayOrder = 999999
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local function mk(instanceType, props)
	local inst = Instance.new(instanceType)
	for k, v in pairs(props) do inst[k] = v end
	return inst
end

local function tween(obj, info, props)
	local t = TweenService:Create(obj, info, props)
	t:Play()
	return t
end

local rainbowStrokes = {} :: { UIStroke }
local rainbowTexts = {} :: { TextLabel }
local rainbowSwitches = {} :: { [TextButton]: boolean }

-- ✅ FIX: pulse uses a stored "original thickness" so it never creeps bigger
local pulseStrokes = {} :: { UIStroke }
local pulseBaseThickness = {} :: { [UIStroke]: number }
local pulseInFlight = {} :: { [UIStroke]: boolean }

local function pulseUI()
	for _, s in ipairs(pulseStrokes) do
		if not (s and s.Parent) then
			pulseInFlight[s] = nil
			pulseBaseThickness[s] = nil
			continue
		end

		-- prevent stacking pulses on same stroke
		if pulseInFlight[s] then
			-- hard-reset to base to avoid “stuck bigger” even if spammed
			local base = pulseBaseThickness[s] or s.Thickness
			s.Thickness = base
			continue
		end

		pulseInFlight[s] = true
		local base = pulseBaseThickness[s] or s.Thickness
		pulseBaseThickness[s] = base

		-- always start from base
		s.Thickness = base

		local up = tween(s, TweenInfo.new(0.10, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Thickness = base + 2 })
		up.Completed:Connect(function()
			if not (s and s.Parent) then
				pulseInFlight[s] = nil
				return
			end
			local down = tween(s, TweenInfo.new(0.16, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Thickness = base })
			down.Completed:Connect(function()
				if s and s.Parent then
					s.Thickness = base
				end
				pulseInFlight[s] = nil
			end)
		end)
	end
end

local function addHover(btn: TextButton)
	btn.MouseEnter:Connect(function()
		tween(btn, TweenInfo.new(0.10, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { BackgroundColor3 = REBIND_BG_HOVER })
	end)
	btn.MouseLeave:Connect(function()
		tween(btn, TweenInfo.new(0.10, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { BackgroundColor3 = REBIND_BG_IDLE })
	end)
	btn.MouseButton1Down:Connect(function()
		btn.BackgroundColor3 = REBIND_BG_DOWN
	end)
	btn.MouseButton1Up:Connect(function()
		local pos = UserInputService:GetMouseLocation()
		local absPos, absSize = btn.AbsolutePosition, btn.AbsoluteSize
		local inside = pos.X >= absPos.X and pos.X <= absPos.X + absSize.X and pos.Y >= absPos.Y and pos.Y <= absPos.Y + absSize.Y
		btn.BackgroundColor3 = inside and REBIND_BG_HOVER or REBIND_BG_IDLE
	end)
end

-- =========================
-- PANEL (thinner border)
-- =========================
local panel = mk("Frame", {
	Name = "Panel",
	Size = UDim2.fromOffset(S(410), S(620)),
	Position = UDim2.fromOffset(S(20), S(120)),
	BackgroundColor3 = Color3.fromRGB(10, 10, 12),
	BorderSizePixel = 0,
	ZIndex = 50,
	Parent = gui,
})
local openSize = panel.Size
panel.ClipsDescendants = true
mk("UICorner", { CornerRadius = UDim.new(0, S(18)), Parent = panel })

local panelStroke = mk("UIStroke", {
	Thickness = 1,
	Color = Color3.fromRGB(255, 0, 0),
	Transparency = 0,
	ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
	LineJoinMode = Enum.LineJoinMode.Round,
	Parent = panel,
})
table.insert(rainbowStrokes, panelStroke)
table.insert(pulseStrokes, panelStroke)
pulseBaseThickness[panelStroke] = panelStroke.Thickness

local inner = mk("Frame", {
	Name = "Inner",
	Size = UDim2.new(1, -S(12), 1, -S(12)),
	Position = UDim2.fromOffset(S(6), S(6)),
	BackgroundColor3 = Color3.fromRGB(18, 18, 22),
	BorderSizePixel = 0,
	ZIndex = 51,
	Parent = panel,
})
mk("UICorner", { CornerRadius = UDim.new(0, S(16)), Parent = inner })

local top = mk("Frame", {
	Name = "Top",
	Size = UDim2.new(1, 0, 0, S(46)),
	BackgroundTransparency = 1,
	ZIndex = 52,
	Parent = inner,
})

local title = mk("TextLabel", {
	Name = "Title",
	Size = UDim2.new(1, -S(120), 1, 0),
	Position = UDim2.fromOffset(S(12), 0),
	BackgroundTransparency = 1,
	Text = "OS Inspector",
	TextXAlignment = Enum.TextXAlignment.Left,
	Font = Enum.Font.GothamBlack,
	TextSize = S(15),
	TextColor3 = Color3.fromRGB(255, 0, 0),
	ZIndex = 53,
	Parent = top,
})
table.insert(rainbowTexts, title)

local minimizeBtn = mk("TextButton", {
	Name = "Minimize",
	Size = UDim2.fromOffset(S(36), S(28)),
	Position = UDim2.new(1, -S(48), 0, S(9)),
	BackgroundColor3 = Color3.fromRGB(28, 28, 34),
	Text = "—",
	Font = Enum.Font.GothamBold,
	TextSize = S(16),
	TextColor3 = Color3.fromRGB(235, 235, 245),
	AutoButtonColor = true,
	ZIndex = 54,
	Parent = top,
})
mk("UICorner", { CornerRadius = UDim.new(0, S(12)), Parent = minimizeBtn })

local content = mk("Frame", {
	Name = "Content",
	Size = UDim2.new(1, -S(18), 1, -S(58)),
	Position = UDim2.fromOffset(S(9), S(52)),
	BackgroundTransparency = 1,
	ZIndex = 52,
	Parent = inner,
})

local function sectionHeader(text, y)
	return mk("TextLabel", {
		Size = UDim2.new(1, 0, 0, S(18)),
		Position = UDim2.fromOffset(0, S(y)),
		BackgroundTransparency = 1,
		TextXAlignment = Enum.TextXAlignment.Left,
		Font = Enum.Font.GothamSemibold,
		TextSize = S(11),
		TextColor3 = Color3.fromRGB(180, 180, 200),
		Text = text,
		ZIndex = 53,
		Parent = content,
	})
end

-- ✅ iPhone switch row (CLICK LABEL OR SWITCH)
local function createIosSwitchRow(parent: Instance, rowY: number, labelText: string, onToggle: () -> ())
	local row = mk("Frame", {
		Size = UDim2.new(1, 0, 0, BUTTON_HEIGHT),
		Position = UDim2.fromOffset(0, S(rowY)),
		BackgroundTransparency = 1,
		ZIndex = 53,
		Parent = parent,
	})

	local labelBtn = mk("TextButton", {
		Size = UDim2.new(1, -(SWITCH_WIDTH + SWITCH_GAP), 1, 0),
		BackgroundTransparency = 1,
		TextXAlignment = Enum.TextXAlignment.Left,
		Text = labelText,
		Font = Enum.Font.Gotham,
		TextSize = S(12),
		TextColor3 = Color3.fromRGB(225, 225, 240),
		AutoButtonColor = false,
		ZIndex = 54,
		Parent = row,
	})

	local switch = mk("TextButton", {
		Size = UDim2.fromOffset(SWITCH_WIDTH, SWITCH_HEIGHT),
		Position = UDim2.new(1, -SWITCH_WIDTH, 0.5, -math.floor(SWITCH_HEIGHT / 2)),
		BackgroundColor3 = SWITCH_OFF,
		Text = "",
		AutoButtonColor = false,
		ZIndex = 54,
		Parent = row,
	})
	mk("UICorner", { CornerRadius = UDim.new(1, 0), Parent = switch })

	local knob = mk("Frame", {
		Size = UDim2.fromOffset(SWITCH_KNOB_SIZE, SWITCH_KNOB_SIZE),
		Position = UDim2.fromOffset(SWITCH_PADDING, SWITCH_PADDING),
		BackgroundColor3 = Color3.fromRGB(245, 245, 255),
		ZIndex = 55,
		Parent = switch,
	})
	mk("UICorner", { CornerRadius = UDim.new(1, 0), Parent = knob })
	mk("UIStroke", { Thickness = 1, Color = Color3.fromRGB(0, 0, 0), Transparency = 0.78, Parent = knob })

	local function setOn(state: boolean, instant: boolean?)
		if state then
			rainbowSwitches[switch] = true
		else
			rainbowSwitches[switch] = nil
			switch.BackgroundColor3 = SWITCH_OFF
		end

		local pos = state
			and UDim2.fromOffset(SWITCH_WIDTH - SWITCH_KNOB_SIZE - SWITCH_PADDING, SWITCH_PADDING)
			or UDim2.fromOffset(SWITCH_PADDING, SWITCH_PADDING)
		if instant then
			knob.Position = pos
		else
			tween(knob, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = pos })
		end
	end

	switch.MouseButton1Click:Connect(onToggle)
	labelBtn.MouseButton1Click:Connect(onToggle)

	return { switch = switch, setOn = setOn }
end

-- =========================
-- ARM SWITCHES
-- =========================
sectionHeader("ARM (GATES INPUT)", 0)

local espArmCtl
local noclipArmCtl
local aimArmCtl

espArmCtl = createIosSwitchRow(content, 20, "ESP Armed", function()
	espArmed = not espArmed
	espArmCtl.setOn(espArmed)
	pulseUI()
	if not espArmed then
		espEnabled = false
		removeAllHighlights()
	end
end)

noclipArmCtl = createIosSwitchRow(content, 52, "Noclip Armed", function()
	noclipArmed = not noclipArmed
	noclipArmCtl.setOn(noclipArmed)
	pulseUI()
	if not noclipArmed then
		setNoclipState(false)
	end
end)

aimArmCtl = createIosSwitchRow(content, 84, "Aim Armed", function()
	aimArmed = not aimArmed
	aimArmCtl.setOn(aimArmed)
	pulseUI()
	if not aimArmed then
		aimStop()
	end
end)

espArmCtl.setOn(true, true)
noclipArmCtl.setOn(true, true)
aimArmCtl.setOn(true, true)

-- =========================
-- KEYBINDS (rebind)
-- =========================
sectionHeader("KEYBINDS", 122)

local function bindToString(bind)
	if bind.kind == "KeyCode" then
		return tostring(bind.value):gsub("Enum.KeyCode.", "")
	end
	if bind.kind == "UserInputType" then
		local v = bind.value
		if v == Enum.UserInputType.MouseButton1 then return "Left Click" end
		if v == Enum.UserInputType.MouseButton2 then return "Right Click" end
		if v == Enum.UserInputType.MouseButton3 then return "Middle Click" end
		return tostring(v):gsub("Enum.UserInputType.", "")
	end
	return "?"
end

local function makePillButton(text, y)
	local btn = mk("TextButton", {
		Size = UDim2.new(1, 0, 0, BUTTON_HEIGHT),
		Position = UDim2.fromOffset(0, S(y)),
		BackgroundColor3 = REBIND_BG_IDLE,
		Text = text,
		Font = Enum.Font.GothamBold,
		TextSize = S(12),
		TextColor3 = Color3.fromRGB(245, 245, 255),
		AutoButtonColor = false,
		ZIndex = 54,
		Parent = content,
	})
	mk("UICorner", { CornerRadius = UDim.new(0, S(12)), Parent = btn })
	mk("UIStroke", { Thickness = 1, Color = Color3.fromRGB(120, 120, 150), Transparency = 0.55, Parent = btn })
	addHover(btn)
	return btn
end

local waitingFor: string? = nil
local espRebindBtn = makePillButton(("Rebind ESP: %s"):format(bindToString(espBind)), 142)
local aimRebindBtn = makePillButton(("Rebind Aim: %s"):format(bindToString(aimBind)), 178)
local noclipRebindBtn = makePillButton(("Rebind Noclip: %s"):format(bindToString(noclipBind)), 214)

local function stopRebind()
	waitingFor = nil
	espRebindBtn.Text = ("Rebind ESP: %s"):format(bindToString(espBind))
	aimRebindBtn.Text = ("Rebind Aim: %s"):format(bindToString(aimBind))
	noclipRebindBtn.Text = ("Rebind Noclip: %s"):format(bindToString(noclipBind))
end

espRebindBtn.MouseButton1Click:Connect(function()
	waitingFor = "ESP"
	espRebindBtn.Text = "Press a key / mouse..."
	aimRebindBtn.Text = ("Rebind Aim: %s"):format(bindToString(aimBind))
	noclipRebindBtn.Text = ("Rebind Noclip: %s"):format(bindToString(noclipBind))
end)

aimRebindBtn.MouseButton1Click:Connect(function()
	waitingFor = "AIM"
	aimRebindBtn.Text = "Press a key / mouse..."
	espRebindBtn.Text = ("Rebind ESP: %s"):format(bindToString(espBind))
	noclipRebindBtn.Text = ("Rebind Noclip: %s"):format(bindToString(noclipBind))
end)

noclipRebindBtn.MouseButton1Click:Connect(function()
	waitingFor = "NOCLIP"
	noclipRebindBtn.Text = "Press a key / mouse..."
	espRebindBtn.Text = ("Rebind ESP: %s"):format(bindToString(espBind))
	aimRebindBtn.Text = ("Rebind Aim: %s"):format(bindToString(aimBind))
end)

-- allow MouseButton1 (Left Click) to be bound normally
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if not waitingFor then return end

	local newBind = nil
	if input.UserInputType == Enum.UserInputType.Keyboard then
		newBind = { kind = "KeyCode", value = input.KeyCode }
	else
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.MouseButton2
			or input.UserInputType == Enum.UserInputType.MouseButton3 then
			newBind = { kind = "UserInputType", value = input.UserInputType }
		end
	end

	if not newBind then return end

	if waitingFor == "ESP" then espBind = newBind end
	if waitingFor == "AIM" then aimBind = newBind end
	if waitingFor == "NOCLIP" then noclipBind = newBind end
	stopRebind()
end)

-- =========================
-- PARTS (two columns, no scroll)
-- =========================
sectionHeader("HITBOX LOCK (ONE AT A TIME)", 260)

local partsArea = mk("Frame", {
	Name = "PartsArea",
	Size = UDim2.new(1, 0, 0, 0),
	AutomaticSize = Enum.AutomaticSize.Y,
	Position = UDim2.fromOffset(0, S(282)),
	BackgroundTransparency = 1,
	ZIndex = 53,
	Parent = content,
})
mk("UIListLayout", { SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, S(6)), Parent = partsArea })

local partControls = {} :: { [string]: { setOn: (boolean, boolean?)->() } }
local dropdowns = {} :: { { titleLabel: TextLabel, baseTitle: string, parts: { [string]: string } } }
local dropdownByPart = {} :: { [string]: { titleLabel: TextLabel, baseTitle: string, parts: { [string]: string } } }
local basePanelHeightOffset = 0
local expandedMenus = {} :: { [Frame]: boolean }
local menuHeights = {} :: { [Frame]: number }

local function setSelectedPart(partKey: string)
	selectedPartName = partKey
	for k, ctl in pairs(partControls) do
		ctl.setOn(k == partKey)
	end
	local dropdown = dropdownByPart[partKey]
	if dropdown then
		local label = dropdown.parts[partKey]
		dropdown.titleLabel.Text = ("%s: %s"):format(dropdown.baseTitle, label)
	end
	if aimEnabled then aimStart() end
end

local function createCompactPartRow(parent: Instance, labelText: string, partKey: string)
	local row = mk("Frame", { Size = UDim2.new(1, 0, 0, BUTTON_HEIGHT), BackgroundTransparency = 1, ZIndex = 54, Parent = parent })

	local labelBtn = mk("TextButton", {
		Size = UDim2.new(1, -(SWITCH_WIDTH + SWITCH_GAP), 1, 0),
		BackgroundTransparency = 1,
		TextXAlignment = Enum.TextXAlignment.Left,
		Font = Enum.Font.Gotham,
		TextSize = S(11),
		TextColor3 = Color3.fromRGB(220, 220, 235),
		Text = labelText,
		AutoButtonColor = false,
		ZIndex = 55,
		Parent = row,
	})

	local sw = mk("TextButton", {
		Size = UDim2.fromOffset(SWITCH_WIDTH, SWITCH_HEIGHT),
		Position = UDim2.new(1, -SWITCH_WIDTH, 0.5, -math.floor(SWITCH_HEIGHT / 2)),
		BackgroundColor3 = SWITCH_OFF,
		Text = "",
		AutoButtonColor = false,
		ZIndex = 55,
		Parent = row,
	})
	mk("UICorner", { CornerRadius = UDim.new(1, 0), Parent = sw })

	local knob = mk("Frame", {
		Size = UDim2.fromOffset(SWITCH_KNOB_SIZE, SWITCH_KNOB_SIZE),
		Position = UDim2.fromOffset(SWITCH_PADDING, SWITCH_PADDING),
		BackgroundColor3 = Color3.fromRGB(245, 245, 255),
		ZIndex = 56,
		Parent = sw,
	})
	mk("UICorner", { CornerRadius = UDim.new(1, 0), Parent = knob })

	local function setOn(state: boolean, instant: boolean?)
		if state then
			rainbowSwitches[sw] = true
		else
			rainbowSwitches[sw] = nil
			sw.BackgroundColor3 = SWITCH_OFF
		end
		local pos = state
			and UDim2.fromOffset(SWITCH_WIDTH - SWITCH_KNOB_SIZE - SWITCH_PADDING, SWITCH_PADDING)
			or UDim2.fromOffset(SWITCH_PADDING, SWITCH_PADDING)
		if instant then
			knob.Position = pos
		else
			tween(knob, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = pos })
		end
	end

	local function clicked() setSelectedPart(partKey) end
	sw.MouseButton1Click:Connect(clicked)
	labelBtn.MouseButton1Click:Connect(clicked)

	partControls[partKey] = { setOn = setOn }
end

local function updatePanelHeight()
	local totalExtra = 0
	for menu, isOpen in pairs(expandedMenus) do
		if isOpen then
			totalExtra += menuHeights[menu] or 0
		end
	end
	local baseHeight = basePanelHeightOffset
	openSize = UDim2.fromOffset(panel.Size.X.Offset, baseHeight + totalExtra)
	tween(panel, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Size = openSize })
end

local function createDropdown(parent: Instance, titleText: string, options: { [number]: { key: string, label: string } })
	local container = mk("Frame", {
		Size = UDim2.new(1, 0, 0, 0),
		AutomaticSize = Enum.AutomaticSize.Y,
		BackgroundTransparency = 1,
		ZIndex = 54,
		Parent = parent,
	})
	mk("UIListLayout", { SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 0), Parent = container })

	local header = mk("TextButton", {
		Size = UDim2.new(1, 0, 0, BUTTON_HEIGHT),
		BackgroundColor3 = REBIND_BG_IDLE,
		Text = "",
		AutoButtonColor = false,
		ZIndex = 54,
		Parent = container,
	})
	mk("UICorner", { CornerRadius = UDim.new(0, S(10)), Parent = header })
	local headerStroke = mk("UIStroke", { Thickness = 1, Color = Color3.fromRGB(255, 0, 0), Transparency = 0, Parent = header })
	table.insert(rainbowStrokes, headerStroke)

	local titleLabel = mk("TextLabel", {
		Size = UDim2.new(1, -S(34), 1, 0),
		Position = UDim2.fromOffset(S(10), 0),
		BackgroundTransparency = 1,
		TextXAlignment = Enum.TextXAlignment.Left,
		Font = Enum.Font.GothamSemibold,
		TextSize = S(11),
		TextColor3 = Color3.fromRGB(230, 230, 245),
		Text = titleText,
		ZIndex = 55,
		Parent = header,
	})

	local caret = mk("TextLabel", {
		Size = UDim2.fromOffset(0, 0),
		Position = UDim2.new(1, 0, 0, 0),
		BackgroundTransparency = 1,
		Text = "",
		Font = Enum.Font.GothamBold,
		TextSize = S(12),
		TextColor3 = Color3.fromRGB(200, 200, 215),
		ZIndex = 55,
		Parent = header,
	})

	local spacer = mk("Frame", {
		Size = UDim2.new(1, 0, 0, 0),
		BackgroundTransparency = 1,
		ZIndex = 54,
		Parent = container,
	})

	local menu = mk("Frame", {
		Size = UDim2.new(1, 0, 0, 0),
		AutomaticSize = Enum.AutomaticSize.None,
		BackgroundColor3 = Color3.fromRGB(18, 18, 22),
		BackgroundTransparency = 0,
		Visible = false,
		ClipsDescendants = true,
		ZIndex = 54,
		Parent = container,
	})
	mk("UICorner", { CornerRadius = UDim.new(0, S(10)), Parent = menu })
	local menuStroke = mk("UIStroke", { Thickness = 1, Color = Color3.fromRGB(255, 0, 0), Transparency = 0, Parent = menu })
	table.insert(rainbowStrokes, menuStroke)
	local menuPadding = mk("UIPadding", { PaddingTop = UDim.new(0, S(6)), PaddingBottom = UDim.new(0, S(6)), PaddingLeft = UDim.new(0, S(6)), PaddingRight = UDim.new(0, S(6)), Parent = menu })
	local menuLayout = mk("UIListLayout", { SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, S(6)), Parent = menu })

	local partMap = {}
	for _, opt in ipairs(options) do
		createCompactPartRow(menu, opt.label, opt.key)
		partMap[opt.key] = opt.label
	end

	local dropdown = { titleLabel = titleLabel, baseTitle = titleText, parts = partMap }
	table.insert(dropdowns, dropdown)
	for key, _ in pairs(partMap) do
		dropdownByPart[key] = dropdown
	end

	local expanded = false
	header.MouseButton1Click:Connect(function()
		expanded = not expanded
		headerStroke.Thickness = expanded and 2 or 1
		expandedMenus[menu] = expanded
		if expanded then
			menu.Visible = true
			spacer.Size = UDim2.new(1, 0, 0, S(4))
			local contentHeight = menuLayout.AbsoluteContentSize.Y
			local paddingHeight = menuPadding.PaddingTop.Offset + menuPadding.PaddingBottom.Offset
			local targetHeight = contentHeight + paddingHeight
			menuHeights[menu] = targetHeight + spacer.Size.Y.Offset
			menu.Size = UDim2.new(1, 0, 0, 0)
			updatePanelHeight()
			tween(menu, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Size = UDim2.new(1, 0, 0, targetHeight) })
		else
			spacer.Size = UDim2.new(1, 0, 0, 0)
			menuHeights[menu] = 0
			expandedMenus[menu] = false
			updatePanelHeight()
			local closeTween = tween(menu, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Size = UDim2.new(1, 0, 0, 0) })
			closeTween.Completed:Connect(function()
				if not expanded then
					menu.Visible = false
				end
			end)
		end
	end)

	header.MouseEnter:Connect(function()
		header.BackgroundColor3 = REBIND_BG_HOVER
	end)
	header.MouseLeave:Connect(function()
		header.BackgroundColor3 = REBIND_BG_IDLE
	end)
end

createCompactPartRow(partsArea, "Head", "Head")
createCompactPartRow(partsArea, "Torso", "Torso")

createDropdown(partsArea, "Arms", {
	{ key = "LeftUpperArm", label = "Left Upper Arm" },
	{ key = "LeftLowerArm", label = "Left Lower Arm" },
	{ key = "LeftHand", label = "Left Hand" },
	{ key = "RightUpperArm", label = "Right Upper Arm" },
	{ key = "RightLowerArm", label = "Right Lower Arm" },
	{ key = "RightHand", label = "Right Hand" },
})

createDropdown(partsArea, "Legs", {
	{ key = "LeftUpperLeg", label = "Left Upper Leg" },
	{ key = "LeftLowerLeg", label = "Left Lower Leg" },
	{ key = "LeftFoot", label = "Left Foot" },
	{ key = "RightUpperLeg", label = "Right Upper Leg" },
	{ key = "RightLowerLeg", label = "Right Lower Leg" },
	{ key = "RightFoot", label = "Right Foot" },
})

setSelectedPart("Head")
task.defer(function()
	basePanelHeightOffset = panel.Size.Y.Offset - partsArea.AbsoluteSize.Y - S(4)
	for menu, _ in pairs(menuHeights) do
		menuHeights[menu] = 0
		expandedMenus[menu] = false
	end
	updatePanelHeight()
end)

-- =========================
-- MINIMIZED SQUARE (outline + OS)
-- =========================
local mini = mk("TextButton", {
	Name = "MiniBox",
	Size = UDim2.fromOffset(S(54), S(54)),
	Position = UDim2.fromOffset(S(20), S(120)),
	BackgroundColor3 = Color3.fromRGB(0, 0, 0),
	BackgroundTransparency = 0,
	Text = "",
	Visible = false,
	AutoButtonColor = false,
	ZIndex = 200,
	Parent = gui,
})
mk("UICorner", { CornerRadius = UDim.new(0, S(16)), Parent = mini })

local miniStroke = mk("UIStroke", {
	Thickness = 1,
	Color = Color3.fromRGB(255, 0, 0),
	Transparency = 0,
	ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
	LineJoinMode = Enum.LineJoinMode.Round,
	Parent = mini,
})
table.insert(rainbowStrokes, miniStroke)
table.insert(pulseStrokes, miniStroke)
pulseBaseThickness[miniStroke] = miniStroke.Thickness

local miniText = mk("TextLabel", {
	BackgroundTransparency = 1,
	Size = UDim2.new(1, 0, 1, 0),
	Text = "OS",
	Font = Enum.Font.GothamBlack,
	TextSize = S(18),
	TextColor3 = Color3.fromRGB(255, 0, 0),
	ZIndex = 201,
	Parent = mini,
})
table.insert(rainbowTexts, miniText)

-- =========================
-- Dragging (panel + mini)
-- =========================
local function makeDraggable(frame: GuiObject)
	local dragging = false
	local dragStart = Vector2.zero
	local startPos = UDim2.new()

	frame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
			startPos = frame.Position
		end
	end)

	frame.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if not dragging then return end
		if input.UserInputType ~= Enum.UserInputType.MouseMovement then return end
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end)
end
makeDraggable(panel)
makeDraggable(mini)

-- =========================
-- Minimize/Open (no smush)
-- =========================
local minimized = false
local tweenInfo = TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local function setMinimized(on: boolean)
	if minimized == on then return end
	minimized = on

	if on then
		inner.Visible = false

		mini.Position = panel.Position
		mini.Visible = true

		tween(panel, tweenInfo, { Size = UDim2.fromOffset(S(54), S(54)) })
		task.delay(0.23, function()
			if minimized then
				panel.Visible = false
			end
		end)
	else
		panel.Position = mini.Position
		panel.Size = UDim2.fromOffset(S(54), S(54))
		panel.Visible = true

		inner.Visible = false

		task.delay(0.05, function()
			if not minimized then
				mini.Visible = false
			end
		end)

		tween(panel, tweenInfo, { Size = openSize })

		task.delay(0.18, function()
			if not minimized and panel.Visible then
				inner.Visible = true
			end
		end)
	end
end

minimizeBtn.MouseButton1Click:Connect(function()
	setMinimized(true)
end)

do
	local downPos: Vector2? = nil
	local CLICK_MOVE_THRESHOLD = 6

	mini.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			downPos = input.Position
		end
	end)

	mini.InputEnded:Connect(function(input)
		if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
		if not downPos then return end
		local moved = (input.Position - downPos).Magnitude
		downPos = nil
		if moved <= CLICK_MOVE_THRESHOLD then
			setMinimized(false)
		end
	end)
end

-- =========================
-- BIND MATCH
-- =========================
local function matchesBind(input, bind)
	if bind.kind == "KeyCode" then
		return input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == bind.value
	end
	if bind.kind == "UserInputType" then
		return input.UserInputType == bind.value
	end
	return false
end

-- =========================
-- INPUT (gated by arm)
-- =========================
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if waitingFor then return end

	if matchesBind(input, espBind) then
		if not espArmed then return end
		espEnabled = not espEnabled
		if not espEnabled then
			removeAllHighlights()
		else
			pulseUI()
		end
		return
	end

	if matchesBind(input, aimBind) then
		if not aimArmed then return end
		pulseUI()
		aimStart()
		return
	end

	if matchesBind(input, noclipBind) then
		if not noclipArmed then return end
		setNoclipState(not noclipEnabled)
		pulseUI()
		return
	end
end)

UserInputService.InputEnded:Connect(function(input, gp)
	if gp then return end
	if waitingFor then return end
	if matchesBind(input, aimBind) then
		if not aimArmed then return end
		aimStop()
		return
	end
end)

-- =========================
-- UPDATE LOOP (rainbow + esp + aim)
-- =========================
RunService.RenderStepped:Connect(function()
	local t = os.clock()
	local rainbow = Color3.fromHSV((t * RAINBOW_SPEED) % 1, 1, 1)

	for _, s in ipairs(rainbowStrokes) do
		s.Color = rainbow
	end
	for _, txt in ipairs(rainbowTexts) do
		txt.TextColor3 = rainbow
	end
	for btn, _ in pairs(rainbowSwitches) do
		btn.BackgroundColor3 = rainbow
	end

	if espEnabled then
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr ~= LocalPlayer then
				local hl = ensureHighlight(plr)
				if hl then hl.FillColor = rainbow end
			end
		end
	end

	if aimEnabled then
		if not aimArmed then
			aimStop()
			return
		end

		if not targetPart or not targetPart.Parent then
			targetPart = findLaserClosestPart(selectedPartName)
			if not targetPart then
				aimStop()
				return
			end
		end

		local char = targetPart.Parent
		if not alive(char) then
			targetPart = findLaserClosestPart(selectedPartName)
			if not targetPart then aimStop() end
			return
		end

		ensureLaser()
		updateLaserStart()
		if laserBeam then laserBeam.Color = ColorSequence.new(rainbow) end

		local origin = Camera.CFrame.Position
		Camera.CFrame = CFrame.new(origin, targetPart.Position)
		setLaserEndPosition(targetPart.Position)
	end
end)

RunService.Heartbeat:Connect(function()
	if not noclipEnabled then return end
	for _, p in ipairs(noclipParts) do
		if p and p.Parent then
			applyNoclipToPart(p)
		end
	end
end)

-- =========================
-- CLEANUP
-- =========================
Players.PlayerRemoving:Connect(function(plr)
	removeHighlight(plr)
	if targetPart and plr.Character and targetPart:IsDescendantOf(plr.Character) then
		aimStop()
	end
end)

LocalPlayer.CharacterAdded:Connect(function()
	espEnabled = false
	removeAllHighlights()
	aimStop()
end)
